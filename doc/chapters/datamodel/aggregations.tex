\section[Aggregation Pipelines]{Aggregation Pipelines\footnote{Note that, during
the development of the application, the pipelines designed in this section may
be implemented in some other way \exgratia{different stages or in different
order} in order to improve the performance of the
queries.}}\label{sec:aggregations}

At the start, the scraper needs to know the last date for which data is
available for a specific market, in order to determine at what date should start
downloading the data for that market. To accomplish this, the following
aggregation pipeline is defined:
\begin{enumerate}
	\item \code{\$match} stage to get only the documents for the specific
		\code{market}. This stage includes the entire shard key, so the
		query is irected only to the specific server where the shard
		containing the documents is saved;
	\item \code{\$sort} stage to order the documents ascending by the
		\code{start} field;
	\item \code{\$group} stage to get the \code{start} field of the first
		document and the \code{candles.t} field of the last candle of
		the last document.
\end{enumerate}

Sometimes it's useful to get paginated results of embedded documents
\exgratia{during the \emph{Browse Markets} use case to get the list of markets}.
To accomplish this, the following aggregation pipeline can be used:
\begin{enumerate}
	\item \textit{(Optional)} \code{\$match} stage to match the documents
		that contains relevant data;
	\item \code{\$unwind} stage to \emph{explode} the embedded documents
		array;
	\item \textit{(Optional)} \code{\$match} stage to filter documents based
		on some search criteria;
	\item \code{\$sort} stage to sort documents based on some sorting
		criteria;
	\item \code{\$skip} and \code{\$limit} stages to paginate the result;
	\item \textit{(Optional)} additional stages to reformat the output in a
		manageable structure.
\end{enumerate}

\subsection{Queries on MarketData}

When the server queries the database for market data \exgratia{when running a
strategy}, it may need:
\begin{enumerate}
	\item\label{itm:granularity} to get a larger granularity of the data
		present in a given market \idest{a strategy may be run with a
		larger granularity than the granularity of the downloaded data};
	\item\label{itm:indicators} to compute some statistical indicators over
		the market data \idest{a strategy may ask the system to provide
		him some statistics about the data};
\end{enumerate}

To accomplish (\ref{itm:granularity}) the following aggregation pipeline has
been defined:
\begin{enumerate}
	\item \ldots TODO \ldots
\end{enumerate}

The above aggregation returns the market data in the format shown in
\lstref{lst:pipelinegranularity}.

\lstinputlisting[language=json, label={lst:pipelinegranularity},
caption={Example of output of the aggregation pipeline used to get market data
at larger granularity.}]{pipelinegranularity.json}

To accomplish (\ref{itm:indicators}) we can define an aggregation pipeline for
each indicator supported by the application. These aggregation pipeline should
be applied to the result of the above aggregation pipeline (the one that
produces the output shown in~\lstref{lst:pipelinegranularity}). Multiple
aggregation pipeline that compute different indicators may be appended to a
single pipeline with a \code{\$facet} stage, so that with just one pipeline we
can return the full list of candles of the market at the requested granularity
along with the values of the requested indicators for each candle.

In the following we define some indicators that are frequently used in technical
analysis of financial markets along with the aggregation pipeline used to
compute them. In the final implementation, a lot indicators may be defined and
implemented. Here we will define only some of them just to give an idea of how
it works.

At the end, the final output of the complete aggregation pipeline (including the
\code{\$facet} stage with the pipelines for the requested indicators) will be
something like the output shown in~\lstref{lst:pipelineoutput}.

\lstinputlisting[language=json, label={lst:pipelineoutput},
caption={Example of output of the complete aggregation pipeline with the
computation of two indicators (EMA and RS).}]{pipelineoutput.json}

\subsubsection{Simple Moving Average}

The Simple Moving Average (\(\sma\)), computed on the closing price of the
candles (\(C\)), at a particular trading day \(t\), over a time period of \(n\)
trading days, is defined as follows:

\begin{equation}\label{eq:sma}
	\sma_n(C,t) = \frac{\sum_{i = n - t}^n C_i}{n}
\end{equation}

We can compute the \(\sma\) with the following aggregation pipeline:

\begin{enumerate}
	\item \ldots TODO \ldots
\end{enumerate}

\subsubsection{Exponential Moving Average}

The Exponential Moving Average (\(\ema\)), computed on the closing price of the
candles (\(C\)), is defined with the following recursive function over the
trading day \(t\):

\begin{equation}\label{eq:ema}
	\begin{cases}
		\ema_{\alpha}(C,0) = C_0\\
		\ema_{\alpha}(C,t) = C_t\times\alpha +
		\ema_{\alpha}(t-1)\times(1-\alpha)
	\end{cases}
\end{equation}

Where \(\alpha\) is a parameter chosen in the range \(\interval{0}{1}\).

We can compute the \(\ema\) with the following aggregation pipeline:

\begin{enumerate}
	\item \ldots TODO \ldots
\end{enumerate}

\subsubsection{Relative Strength Index}

The Relative Strength Index (\(\rsi\)), at a particular trading day \(t\), over
a time period of \(n\) trading days, is defined as follows:

\begin{equation}\label{eq:rsi}
	\rsi_n(t) = 100 - \frac{100}{1 + \rs_n(t)}
\end{equation}

The \(\rsi\) is a derived indicator that depends on the Relative Strength
(\(\rs\)) indicator.

The Relative Strength (\(\rs\)) indicator, at a particular trading day \(t\),
over a time period of \(n\) trading days, is defined as follows:

\begin{equation}\label{eq:rs}
	\rs_n(t) = \frac{\sma_{n_U}(U,t)}{\sma_{n_D}(D,t)}
\end{equation}

Where \(\sma_{n_U}(U,t)\) is the \(\sma\) of the increment (\(C_t - O_t\)) in
price of all rising candles in the last \(n\) days, and \(\sma_{n_D}(D,t)\) is
the \(\sma\) of the decrement (\(O_t - C_t\)) in price of all falling candles in
the last \(n\) days. \(n_U\) is the number of rising candles while \(n_D\) is
the number of falling candles.

We can compute the \(\rs\) with the following aggregation pipeline (the \(\rsi\)
can then be computed by the server application applying the~\eqref{eq:rsi} to
the \(\rs\) value):

\begin{enumerate}
	\item \ldots TODO \ldots
\end{enumerate}

\subsubsection{Momentum Indicator}

The Momentum Indicator (\(\mom\)), computed on the closing price of the candles
(\(C\)), at a particular trading day \(t\), over a time period of \(n\) trading
days, is defined as follows:

\begin{equation}\label{eq:mom}
	\mom_n(C,t) = C_t - C_{n-t}
\end{equation}

We can compute the \(\mom\) with the following aggregation pipeline:

\begin{enumerate}
	\item \ldots TODO \ldots
\end{enumerate}
